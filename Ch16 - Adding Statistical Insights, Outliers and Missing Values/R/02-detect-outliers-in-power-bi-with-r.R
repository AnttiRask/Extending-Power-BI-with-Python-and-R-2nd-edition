library(dplyr)
library(recipes)
library(stringr)
library(robust)

add_is_outlier_IQR <- function(data, col_name) {
    
    x    <- data[[col_name]]
    quar <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
    iqr  <- diff(quar)
    k    <- 1.5
    
    outliers_col_name <- str_glue('is_{str_replace(col_name, " ", "_")}_outlier')
    
    data[[outliers_col_name]] <- ifelse((x < quar[1] - k * iqr) | (x > quar[2] + k * iqr), 1, 0)
    
    return(data)
}

yeo_johnson_transf <- function(data, target_name) {
    
    rec <- recipe(data, as.formula(paste0(target_name, ' ~ .')))
    
    rec <- rec %>%
        step_center(all_numeric(), - all_outcomes()) %>%
        step_scale(all_numeric(), - all_outcomes()) %>%
        step_YeoJohnson(all_numeric(), -all_outcomes())
    
    prep_rec <- prep( rec, training = data )
    
    res_list <- list(
        df_yeojohnson = bake(prep_rec, data),
        lambdas       = prep_rec$steps[[3]][["lambdas"]]
    )
}

# Get numeric column names but the quality
numeric_col_names <- dataset %>% 
    select(where(is.numeric), -quality) %>% 
    names()

# As you see there are outliers, let's add a boolean column to the dataframeindicating which row
# has a sulphate outlier
df <- add_is_outlier_IQR(dataset, col_name = 'sulphates')

# Let's remove the initial outliers
df_no_outliers <- df %>%
    filter(is_sulphates_outlier == 0) %>% 
    as_tibble()

# Let's apply Yeo-Johnson transformations in order to remove skewness
yeo_johnson_list <- df_no_outliers %>% 
    yeo_johnson_transf(target_name = 'quality')

df_transf <- yeo_johnson_list$df_yeojohnson

# Let's compute the squared Mahalanobis distances using the Minimum Covariance Determinant to calculate a
# robust covariance matrix
data <- df_transf %>%
    select(all_of(numeric_col_names))

cov_obj <- data %>% 
    covRob(estim = "mcd", alpha = 0.7)

center    <- cov_obj$center
cov       <- cov_obj$cov
distances <- data %>%
    mahalanobis(center = center, cov = cov)

distances

# Given a cutoff value associated with the statistical significance with which we want to determine outliers,
# we obtain the corresponding threshold value above which to consider an observation an outlier
cutoff                <- 0.98
degrees_of_freedom    <- ncol(data) # given by the number of variables (columns)
outliers_value_cutoff <- qchisq(cutoff, degrees_of_freedom) # threshold value
df_no_outliers        <- df_no_outliers %>% 
    mutate(
        
        # Indicator column of outliers detected with Mahalanobis distance
        is_mahalanobis_outlier    = distances > outliers_value_cutoff,
        
        # Probability that an observation is an outlier not by chance
        mahalanobis_outlier_proba = pchisq(distances, ncol(data))
    )